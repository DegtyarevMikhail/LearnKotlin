package example

data class Note (val title: String, val note: String, val color: Int) {

   // val newCopy = weather.copy(town = "Санкт-Петербург")

/*
Часто мы применяем классы (POJO) как объект только для хранения данных.
Чтобы использовать такой класс,
надо создать геттеры и сеттеры для каждого поля класса,
переопределить методы equals(), hashCode() и, желательно, toString().
Затем в классе получается больше бойлерплейт-кода, чем кода,
который мы действительно хотим использовать.
Kotlin предлагает для таких случаев изящное решение — data class:
data class Note(val title: String, val note: String, val color: Int)


Ключевое слово data перед декларацией класса даёт компилятору понять, что мы хотим, чтобы он сгенерировал методы доступа к свойствам, а также методы equals() и hashCode(), toString(). equals() и hashCode() будут учитывать все свойства, объявленные в главном конструкторе.
Компилятор создаёт для data-классов ещё один метод — copy(), который добавляет копию этого объекта. Чтобы понять замысел создателей языка, вспомним, что hashCode() и equals() учитывают все свойства класса.
Представим ситуацию: есть HashMap, ключи в которой — это объекты. Если изменим какое-нибудь свойство такого объекта, больше не сможем получить значение из HashMap по нему, так как его hashCode изменился. Чтобы избежать таких ситуаций, создатели Kotlin рекомендуют использовать метод copy() для изменения объектов:
val newCopy = weather.copy(town = "Санкт-Петербург")


Здесь мы применили именованный параметр, чтобы изменить свойство town нашего класса Weather. Метод copy() использует по умолчанию в качестве параметров свойства копируемого объекта. Если не задать новых значений, получим точную копию объекта. Так, применяя именованные параметры, можно задать новые значения только для некоторых свойств класса, а остальные — просто не указывать. На выходе получаем объект со свойствами копируемого, кроме тех, что изменили.

 */

}